/* Main.c file generated by New Project wizard
 *
 * Created:   Fri Sep 16 2022
 * Processor: PIC18F4520
 * Compiler:  MPLAB XC8
 */

#include <xc.h>
#define _XTAL_FREQ 4000000

#pragma config OSC = XT         // Oscillator Selection bits (XT oscillator)
#pragma config FCMEN = OFF      // Fail-Safe Clock Monitor Enable bit (Fail-Safe Clock Monitor disabled)
#pragma config IESO = OFF       // Internal/External Oscillator Switchover bit (Oscillator Switchover mode disabled)
// CONFIG2L
#pragma config PWRT = OFF       // Power-up Timer Enable bit (PWRT disabled)
#pragma config BOREN = SBORDIS  // Brown-out Reset Enable bits (Brown-out Reset enabled in hardware only (SBOREN is disabled))
#pragma config BORV = 3         // Brown Out Reset Voltage bits (Minimum setting)
// CONFIG2H
#pragma config WDT = OFF        // Watchdog Timer Enable bit (WDT disabled (control is placed on the SWDTEN bit))
#pragma config WDTPS = 32768    // Watchdog Timer Postscale Select bits (1:32768)
// CONFIG3H
#pragma config CCP2MX = PORTC   // CCP2 MUX bit (CCP2 input/output is multiplexed with RC1)
#pragma config PBADEN = OFF     // PORTB A/D Enable bit (PORTB<4:0> pins are configured as digital I/O on Reset)
#pragma config LPT1OSC = OFF    // Low-Power Timer1 Oscillator Enable bit (Timer1 configured for higher power operation)
#pragma config MCLRE = ON       // MCLR Pin Enable bit (MCLR pin enabled; RE3 input pin disabled)
// CONFIG4L
#pragma config STVREN = ON      // Stack Full/Underflow Reset Enable bit (Stack full/underflow will cause Reset)
#pragma config LVP = ON         // Single-Supply ICSP Enable bit (Single-Supply ICSP enabled)
#pragma config XINST = OFF      // Extended Instruction Set Enable bit (Instruction set extension and Indexed Addressing mode disabled (Legacy mode))


unsigned long c,d=0;
unsigned char nextseg=1;
unsigned char pattern[10]={0x3F,0x06,0x5B,0x4F,0x66,0x6d,0x7d,0x07,0x7f,0x6f};
unsigned char s,m,h;
unsigned int tick_1ms=0;

void keeptime(void);


void main(void)
 {
   __delay_ms(100);
   s=0;m=0;h=0;
   T1CONbits.TMR1CS=0;
   TMR1H=0xEC;
   TMR1L=0x77; // count to 5000. So start at 60535
   
   PIE1bits.TMR1IE=1; //Timer 1 interrupt enable
   RCONbits.IPEN=1; //enable interrupt priorities.
   IPR1bits.TMR1IP=0; //low priority
   // Write your code here
   TRISD=0x00;
   TRISC=0;
   T1CONbits.TMR1ON=1; // start timer 1
   c=0;
   INTCONbits.GIEL=1; 
   INTCONbits.GIE=1;
   TRISE=0x00;
  TRISB=TRISB|0b00000111; 
   while (1)
   {

  
   if(PORTBbits.RB0==1){
        __delay_ms(1);
        if(PORTBbits.RB0==1){
             s=0;
             while(PORTBbits.RB0==1) {};
             }
  }
  
  if(PORTBbits.RB1==1){
             __delay_ms(1);
       if(PORTBbits.RB1==1){
           
     if(m<59){
       m++;
             while(PORTBbits.RB1==1){;}
     }
          else{
    m=0;
    }
      }
   
  }
  if(PORTBbits.RB2==1){
             __delay_ms(1);
       if(PORTBbits.RB2==1){
           
     if(h<23){
       h++;
             while(PORTBbits.RB2==1){;}
     }
          else{
    h=0;
    }
      }
   
  }
   
       // if switch pressed for hrs, increase h by 1 if hrs are less than 23, otherwise set hrs to 0;
       // if min  sw is pressed, if m==59, make m=0, otherwise m++;
       // if sec sw pressed, make s=0;
  
}
}

void __interrupt(low_priority)  myisr()
{
   PIR1bits.TMR1IF=0;
   TMR1H=0xFB;
   TMR1L=0xB3; // count to 5000. So start at 60535
   c++;  
   d++;
   unsigned long temp=d;
   PORTC=0;
   
   tick_1ms++;
   if(tick_1ms==1000)
   {
       tick_1ms=0;
       keeptime();
   }
   
   if (tick_1ms%2==0)
   {
        switch(nextseg)
        {
            case 1: 
            {
                PORTD=pattern[s%10];
                PORTCbits.RC2=1;
                nextseg=2;
                break;
            }
            case 2:
            {
                PORTD=pattern[s/10];
                PORTCbits.RC3=1;
                nextseg=3;
                break;
            }

           case 3:
            {
                PORTD=pattern[m%10];
                PORTCbits.RC4=1;
                nextseg=4;
                break;
            }
            case 4:
            {
                PORTD=pattern[m/10];
                PORTCbits.RC5=1;
                nextseg=5;
                break;
            } 
            case 5:
            {
                PORTD=pattern[h%10];
                PORTCbits.RC6=1;
                nextseg=6;
                break;
            }
            case 6:
            {
                PORTD=pattern[h/10];
                PORTCbits.RC7=1;
                nextseg=1;
                break;
            } 
    }
   }
}
void keeptime(void)
{
       s++;
       if(s>=60)
       {
           m++;
           s=0;
           if(m>=60)
           {
               h++;
               m=0;
               if(h>=24)
               {
                   h=0;
               }
           }
       }
}
